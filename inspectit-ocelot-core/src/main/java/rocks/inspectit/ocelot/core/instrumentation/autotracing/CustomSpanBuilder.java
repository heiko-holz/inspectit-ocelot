package rocks.inspectit.ocelot.core.instrumentation.autotracing;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanContext;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.context.Context;
import io.opentelemetry.sdk.common.Clock;
import io.opentelemetry.sdk.common.InstrumentationScopeInfo;
import io.opentelemetry.sdk.internal.AttributesMap;
import io.opentelemetry.sdk.resources.Resource;
import io.opentelemetry.sdk.trace.IdGenerator;
import io.opentelemetry.sdk.trace.SpanLimits;
import io.opentelemetry.sdk.trace.SpanProcessor;
import lombok.Setter;
import rocks.inspectit.ocelot.core.utils.OpenTelemetryUtils;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * Allows building of spans with custom timestamps.
 */
public class CustomSpanBuilder {

    /**
     * The {@link io.opentelemetry.sdk.trace.AnchoredClock clock} member of {@link io.opentelemetry.sdk.trace.SdkSpan}
     */
    private static final Field SDKSPAN_CLOCK;

    /**
     * The class of {@link io.opentelemetry.sdk.trace.SdkSpan}.
     */
    private static final Class<? extends Span> SDKSPAN_CLASS;

    /**
     * The {@link io.opentelemetry.sdk.trace.SdkSpan#startSpan(SpanContext, String, InstrumentationScopeInfo, SpanKind, Span, Context, SpanLimits, SpanProcessor, Clock, Resource, AttributesMap, List, int, long)} method.
     */
    private final static Method SDKSPAN_START_SPAN_METHOD;

    private final static Class<?> ANCHOREDCLOCK_CLASS;

    private final static Method ANCHOREDCLOCK_CREATE;

    /**
     * Random used to generate span IDs.
     */
    private static final Random RANDOM = new Random();

    /**
     * The span to use as parent.
     */
    private Span parent;

    /**
     * The name to use for the span.
     */
    private String name;

    /**
     * The spanId to use, null if it should be autogenerated.
     */
    private String spanId;

    /**
     * The {@link AnchoredClock} (known as timestamp converter in OpenCensus) to use for the overriden timestamp {@link #entryNanos} and {@link #exitNanos}.
     */
    private Object anchoredClock;

    /**
     * The span kind to assign to the span.
     */
    private SpanKind kind;

    /**
     * The timestamps to use for the new span. If not set, the span takes times as usual.
     */
    private long entryNanos = 0;

    private long exitNanos = 0;

    static {
        try {
            SDKSPAN_CLASS = (Class<Span>) Class.forName("io.opentelemetry.sdk.trace.SdkSpan");
            // SDKSPAN_START_SPAN_METHOD = SDKSPAN_CLASS.getDeclaredMethod("startSpan"); //TODO: add appropriate arguments
            // SDKSPAN_START_SPAN_METHOD.setAccessible(true);
            SDKSPAN_START_SPAN_METHOD = null;
            ANCHOREDCLOCK_CLASS = Class.forName("io.opentelemetry.sdk.trace.AnchoredClock");
            ANCHOREDCLOCK_CREATE = ANCHOREDCLOCK_CLASS.getDeclaredMethod("create", Clock.class);
            ANCHOREDCLOCK_CREATE.setAccessible(true);
            SDKSPAN_CLOCK = SDKSPAN_CLASS.getDeclaredField("clock");
            SDKSPAN_CLOCK.setAccessible(true);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private CustomSpanBuilder(String name, Span parent) {
        this.parent = parent;
        this.name = name;
    }

    public static CustomSpanBuilder builder(String name, Span parent) {
        return new CustomSpanBuilder(name, parent);
    }

    /**
     * Replaces the timings on the resulting Span.
     * An {@link io.opentelemetry.sdk.trace.AnchoredClock} (known as timestamp converter in OpenCensus) must be given if the parent is not a sampled span, otherwise it can be null.
     *
     * @param entryNanos    the nano entry timestamp
     * @param exitNanos     the nano exit timestamp
     * @param anchoredClock the anchored clock (timestamp converter) to use, if null it will be derived from the parent span.
     *
     * @return the builder
     */
    public CustomSpanBuilder customTiming(long entryNanos, long exitNanos, Object anchoredClock) {
        if (anchoredClock == null) {
            if (parent.isRecording()) {
                this.anchoredClock = getAnchoredClock(parent);
            } else {
                throw new IllegalArgumentException("converter may only be null if the parent is a SdkSpan");
            }
        } else {
            if (!ANCHOREDCLOCK_CLASS.equals(anchoredClock.getClass())) {
                throw new IllegalArgumentException("expected AnchoredClock but received {} " + anchoredClock.getClass()
                        .getName());
            }
            this.anchoredClock = anchoredClock;
        }
        this.entryNanos = entryNanos;
        this.exitNanos = exitNanos;
        return this;
    }

    public CustomSpanBuilder spanId(String id) {
        spanId = id;
        return this;
    }

    public CustomSpanBuilder kind(SpanKind kind) {
        this.kind = kind;
        return this;
    }

    public Span startSpan() {
        SpanContext parentContext = parent.getSpanContext();
        // TraceParams params = Tracing.getTraceConfig().getActiveTraceParams();
        String id = spanId != null ? spanId : IdGenerator.random().generateSpanId();

        SpanContext context = SpanContext.create(parentContext.getTraceId(), id, parentContext.getTraceFlags(), parentContext.getTraceState());

        if (entryNanos != 0) {
            DummyClock clock = new DummyClock();
            clock.setValue(entryNanos);

            // TODO: set parent. / check if I need to call the constructor of SdkSpan instead of using the SpanBuilder
            Span result = OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .setStartTimestamp(entryNanos, TimeUnit.NANOSECONDS)
                    .startSpan();
            // result = RecordEventsSpanImpl.startSpan(context, name, kind, parentContext.getSpanId(), false, params, getStartEndHandler(), anchoredClock, clock);
            clock.setValue(exitNanos);
            
            // set the AnchoredClock via reflection.
            setAnchoredClock(result, createAnchoredClock(clock));

            /*
            static SdkSpan startSpan(
      SpanContext context,
      String name,
      InstrumentationScopeInfo instrumentationScopeInfo,
      SpanKind kind,
      Span parentSpan,
      Context parentContext,
      SpanLimits spanLimits,
      SpanProcessor spanProcessor,
      Clock tracerClock,
      Resource resource,
      @Nullable AttributesMap attributes,
      List<LinkData> links,
      int totalRecordedLinks,
      long userStartEpochNanos)
      */

            return result;
        } else {
            // Clock clock = Tracing.getClock();
            // return RecordEventsSpanImpl.startSpan(context, name, kind, parentContext.getSpanId(), false, params, getStartEndHandler(), anchoredClock, clock);
            return OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .startSpan();
        }
    }

    /**
     * Utility method for extracting a {@link io.opentelemetry.sdk.trace.AnchoredClock clock} from a given span.
     *
     * @param span the span to extract the converter from. It must be of type {@link io.opentelemetry.sdk.trace.SdkSpan}
     *
     * @return the extracted clock.
     */
    public static Object getAnchoredClock(Span span) {
        if (!span.getClass().equals(SDKSPAN_CLASS)) {
            throw new IllegalArgumentException(span.getClass() + " is no of type SdkSpan (" + SDKSPAN_CLASS.getName() + ")");
        }
        try {
            return SDKSPAN_CLOCK.get(span);
        } catch (IllegalAccessException e) {
            throw new IllegalStateException("Could not extract AnchoredClock", e);
        }
    }

    /**
     * Sets a new {@link AnchoredClock clock} of the {@link io.opentelemetry.sdk.trace.SdkSpan span}
     *
     * @param span
     * @param anchoredClock
     *
     * @return
     */
    public static void setAnchoredClock(Span span, Object anchoredClock) {
        if (!span.getClass().equals(SDKSPAN_CLASS)) {
            throw new IllegalArgumentException(span.getClass() + " is not of type SdkSpan (" + SDKSPAN_CLASS.getName() + ")");
        }
        if (!anchoredClock.getClass().equals(ANCHOREDCLOCK_CLASS)) {
            throw new IllegalArgumentException(anchoredClock.getClass() + " is not of type AnchoredClock (" + ANCHOREDCLOCK_CLASS.getName() + ")");
        }
        try {
            SDKSPAN_CLOCK.set(span, anchoredClock);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Could not set AnchoredClock", e);
        }
    }

    /**
     * Creates a new {@link AnchoredClock} with the given {@code clock}
     *
     * @param clock
     *
     * @return
     */
    public static Object createAnchoredClock(Clock clock) {
        try {
            return ANCHOREDCLOCK_CREATE.invoke(null, clock);
        } catch (Exception e) {
            throw new RuntimeException("Could not create AnchoredClock (" + ANCHOREDCLOCK_CREATE.getDeclaringClass() + "." + ANCHOREDCLOCK_CREATE.getName() + ")", e);
        }
    }

    private static class DummyClock implements Clock {

        @Setter
        private long value;

        @Override
        public long now() {
            return value;
        }

        @Override
        public long nanoTime() {
            return 0;
        }
    }
}
